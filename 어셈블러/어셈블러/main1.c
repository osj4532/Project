#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <math.h>
#include <stdlib.h> //헤더 부분

//자료구조
struct reg
{
	char reg_name[3]; //AX
	char reg_num[4]; //010
}Reg[20]; //레지스터에 대한 이름과 번호를 저장하는 구조체

struct ins
{
	char instruct[6]; //MOV
	char dest[2]; //도착지의 타입 R M
	char sour[2]; //출발지의 타입 R M I
	char word_type[2]; //W B
	char ins_code[3]; //8A
	char ins_len[2]; //2바이트
	char mod_reg[9]; //111???10
}Instr[100], modInstr[100]; //각 인스트럭션의 정보를 보관하는 구조체, obj 구조체

int MaxI, InstrP = 0;

struct symbol_tbl
{
	char symbol[10]; //DATA
	char word_type[2]; //W
	int lc; //주소값
	char data[10]; //57
}Symbol[30];
int MaxS = 0;

struct sentence
{
	char label[10]; //레이블
	char _operator[10]; //명령어
	char operand[3][10]; //AX, SUM
} Sen; //원시 코드 임시 저장 구조체
int LC; //로케이션 카운터

FILE *ObjSave; //objcode.txt 저장
FILE *SymbolSave; //symbol.txt 저장

//사용자 함수
//파일에서 레지스터와 인스트럭션의 정보를 읽는다.
void Initialize(void)
{
	int i = 0, j = 1;
	FILE *regi, *inst;

	regi = fopen("reg.tbl", "r");
	inst = fopen("inst.tbl", "r");

	while (!feof(regi))
	{
		fscanf(regi, "%s %s\n", Reg[i].reg_name, Reg[i].reg_num);
		i++;
	} //레지스터 테이블 작성

	while (!feof(inst))
	{
		fscanf(inst, "%6s%2s%2s%4s%3s%2s%9s\n", Instr[j].instruct, Instr[j].dest, Instr[j].sour, Instr[j].word_type, Instr[j].ins_code, Instr[j].ins_len, Instr[j].mod_reg);
		j++;
	} //명령어 테이블 작성
	MaxI = j - 1; //명령어의 개수
	fclose(regi);
	fclose(inst);
}

int Analyze(char *operand)
{
	int i = 0;
	char *regist[] = { "AX", "BX", "CX", "DX", "AL", "BL", "CL", "DL", "AH", "BH", "CH", "DH", "SP", "BP", "SI", "DI", "ES", "CS", "SS", "DS", 0x00 };
	//레지스터 이름 저장

	if (isdigit(operand[0])) return 0; //immediate 어드레스 모드를 지정
	else
	{
		while (regist[i] != 0x00)
		{
			if (!strcmp(operand, regist[i]))
			{
				if (i <= 3) return 1; //레지스터 방식 + 워드
				else if(i >= 4 && i <= 11) return 2; //레지스터 방식 + 바이트
				else if (i >= 12) return 3; //세그먼트 레지스터 지정 방식
			}
			else i++;
		}
	}
	return 4; //메모리 지정 방식
}

#define MAX_INS 3 //명령어 최대 개수를 지정, 현재는 MOV만 존재

int Add_Chk(char *sen) //오퍼랜드의 어드레스 모드를 판정
{
	register k = MaxI;
	int i = 0, j = 0, l = 0, wp = 0;
	char op[6][10], *opcode[] = { "mov", "add", "sub", "" }; //분석하고자하는 명령어
	while (sen[wp] != '\n')
	{
		while (sen[wp] == ' ' || sen[wp] == '\t' || sen[wp] == ',' ) wp++; //공백, 탭, 콤마는 통과

		while (sen[wp] != ' ' && sen[wp] != '\t' && sen[wp] != ',' && sen[wp] != '\n')
		{
			*(op[j] + i) = sen[wp];
			i++;
			wp++;
		}
		*(op[j] + i) = '\0'; //마지막에 NULL 삽입
		i = 0;
		j++;
	}
	i = 0;

	while (strcmp(opcode[i], "")) //등록된 명령어의 끝까지 비교
	{
		if (stricmp(opcode[i], op[0])) i++; //mov 명령어와 op[0]이 다르면, 다음 명령어 조회
		else
		{
			strcpy(Sen._operator, op[0]); //명령어를 _operator에 저장
			for (l = 1; l < j; l++)
				strcpy(Sen.operand[l - 1], op[l]); //명령어 뒷 내용을 operand에 저장
			break;
		}
	}
	if (i == MAX_INS) //i = 1이면, 명령어를 찾지 못한 것(명령어 1개 기준)  
	{
		strcpy(Sen.label, op[0]); //이 경우 첫 단어를 레이블에 등록
		strcpy(Sen._operator, op[1]); //두 번째 단어를 명령어에 등록
		for (l = 2; l < j; l++)
			strcpy(Sen.operand[l - 2], op[l]); //그 다음 내용을 operand에 저장
	} //한 문장을 분석하여 레이블, 오퍼레이터와 오퍼랜드로 분류한다.

	strcpy(Instr[0].instruct, op[0]); //명령어를 instruct에 저장

	switch (Analyze(op[1])) //도착지 분석
	{
	case 0: strcpy(Instr[0].dest, "i"); //값 즉시 입력 방식
		break;

	case 1: strcpy(Instr[0].dest, "r"); //레지스터 방식 + 워드
		strcpy(Instr[0].word_type, "w");
		break;

	case 2: strcpy(Instr[0].dest, "r"); //레지스터 방식 + 바이트
		strcpy(Instr[0].word_type, "b");
		break;

	case 3: strcpy(Instr[0].dest, "s");
		break;

	case 4: strcpy(Instr[0].dest, "m"); //메모리 지정 방식
		break;
	}

	switch (Analyze(op[2])) //출발지 분석
	{
	case 0: strcpy(Instr[0].sour, "i"); //값 즉시 입력 방식
		break;

	case 1: strcpy(Instr[0].sour, "r"); //레지스터 방식 + 워드
		strcpy(Instr[0].word_type, "w");
		break;

	case 2: strcpy(Instr[0].sour, "r"); //레지스터 방식 + 바이트
		strcpy(Instr[0].word_type, "b");
		break;

	case 3: strcpy(Instr[0].sour, "s");
		break;

	case 4: strcpy(Instr[0].sour, "m"); //메모리 지정 방식
		break;
	}

	while (stricmp(Instr[k].instruct, Instr[0].instruct) || strcmp(Instr[k].dest, Instr[0].dest) || strcmp(Instr[k].sour, Instr[0].sour) || strcmp(Instr[k].word_type, Instr[0].word_type))
	{//instruct, 즉 현재 명령어와 inst.tbl에서 가져온 명령어를 비교
		k--; //같은 값을 찾을 때까지, k를 감소하며 비교
	}
	return k;
}

void pass1(char *buf)
{
	int i;
	static int j = 0;

	i = Add_Chk(buf); //원시 코드의 명령어 주소 방식을 리턴받음

	if (i) //mov 명령어에 대한 처리
	{
		printf("%04X: %s", LC, buf); //주소값, 원시 코드 출력
		LC += atoi(Instr[i].ins_len); //LC = LC + 명령어 길이
	}
	else //기호에 대한 처리
	{
		if (!stricmp(Sen._operator, "DW"))
			strcpy(Symbol[j].word_type, "w"); //dw라면 w를 저장

		else if (!stricmp(Sen._operator, "DB"))
			strcpy(Symbol[j].word_type, "b"); //db라면 b를 저장

		strcpy(Symbol[j].symbol, Sen.label); //레이블을 심볼에 저장
		strcpy(Symbol[j].data, Sen.operand[0]); //레이블의 값을 저장
		Symbol[j].lc = LC; //주소값을 저장
		printf("%04X: %s", LC, buf); //주소값, 원시 코드 출력

		if (*Symbol[j].word_type == 'w') LC += 2; //주소값을 w=2, b=1만큼 증가
		else if (*Symbol[j].word_type == 'b') LC += 1;

		j++; // j를 증가시켜 다음 번 심볼 인덱스를 맞춰줌
		MaxS++;
	}
}

//2진수를 10진수로 변환
int btoi(char *dig)
{
	register i = 0, ret = 0;

	while (*(dig + i) != '\0')
	{
		if (*(dig + i) == '1') ret += pow(2, strlen(dig + i) - 1);
		//dig+i의 길이는 dig(8)+i(0)으로 -1하면 7이다.
		//기준점인 i가 증가하므로, 7, 6, 5, 4, 3, 2, 1, 0으로 줄어든다.

		i++;
	}
	return ret;
}

void pass2(char *buf)
{
	int i, j = 0, k = 0;
	char tmp[8];
	ObjSave = fopen("objCode.txt", "a+");

	i = Add_Chk(buf);

	if (i) //i != 0일 때, 즉 명령어일 경우,
	{
		modInstr[InstrP] = Instr[i];

		printf("%04X: %3s", LC, Instr[i].ins_code); //LC와 명령어 코드 출력
		fprintf(ObjSave, "%04X: %3s", LC, Instr[i].ins_code);

		if (!strcmp(Instr[i].dest, "r") || !strcmp(Instr[i].dest, "s")) //도착지가 r 또는 s이면
		{
			while (stricmp(Reg[j].reg_name, Sen.operand[0])) j++;//도착지와 레지스터 이름이 같게 맞춤

			strncpy(strchr(modInstr[InstrP].mod_reg, '?'), Reg[j].reg_num, 3);
		}

		j = 0;

		if (!strcmp(Instr[i].sour, "r") || !strcmp(Instr[i].sour, "s")) //출발지가 r 또는 s이면
		{
			while (stricmp(Reg[j].reg_name, Sen.operand[1])) j++;//도착지와 레지스터 이름이 같게 맞춤

			strncpy(strchr(modInstr[InstrP].mod_reg, '?'), Reg[j].reg_num, 3);
			//???를 레지스터 표의 값으로 채움
		}

		if (!strcmp(Instr[i].instruct, "mov") && !strcmp(Instr[i].dest, "r") && !strcmp(Instr[i].sour, "i"))
			strcpy(modInstr[InstrP].mod_reg, itoa(atoi(Sen.operand[1]), tmp, 2));

		if (strcmp(Instr[i].dest, "m") && strcmp(Instr[i].sour, "m")) //도착지, 출발지가 둘다 m이 아니면 
		{
			printf("%02X\t\t%s", btoi(modInstr[InstrP].mod_reg), buf);
			//Instr의 명령어 코드를 16진수로 변환 후 출력, 원시 코드 출력
			fprintf(ObjSave, "%02X\t\t%s", btoi(modInstr[InstrP].mod_reg), buf);
		}
		else //도착지 or 출발지에 기호가 들어간 경우
		{
			if (!strcmp(Instr[i].dest, "m")) //도착지가 m인 경우
				while (strcmp(Symbol[k].symbol, Sen.operand[0])) k++;
			//심볼과 같은 operand를 찾음. 즉 기호를 찾음

			else if (!strcmp(Instr[i].sour, "m")) //출발지가 m인 경우
				while (strcmp(Symbol[k].symbol, Sen.operand[1])) k++;
			//심볼과 같은 operand를 찾음. 즉 기호를 찾음

			if (Symbol[k].lc == (atoi(Symbol[k].data))) //같으면 재배치 불필요
			{
				printf("  %02X\t%04X\t%s", btoi(modInstr[InstrP].mod_reg), Symbol[k].lc, buf);
				fprintf(ObjSave, "  %02X\t%04X\t%s", btoi(modInstr[InstrP].mod_reg), Symbol[k].lc, buf);
			}
			else //다르면 재배치 필요
			{
				printf("  %02X\t%04X R\t%s", btoi(modInstr[InstrP].mod_reg), Symbol[k].lc, buf);
				fprintf(ObjSave, "  %02X\t%04X R\t%s", btoi(modInstr[InstrP].mod_reg), Symbol[k].lc, buf);
				//Instr의 명령어 코드를 16진수 변환 후 출력, 원시 코드 출력
			}
		}
		LC += atoi(Instr[i].ins_len); //LC = LC + 명령어 길이
	}

	else //기호일 경우
	{
		k = 0;

		while (strcmp(Symbol[k].symbol, Sen.label)) k++; //symbol과 label이 같을 때 까지 루프, 같게 만듬

		if (!strcmp(Symbol[k].word_type, "w")) //타입이 w이면
		{
			printf("%04X:%04X\t\t%s", LC, atoi(Symbol[k].data), buf);
			fprintf(ObjSave, "%04X:%04X\t\t%s", LC, atoi(Symbol[k].data), buf);
		}

		if (!strcmp(Symbol[k].word_type, "b")) //타입이 b이면
		{
			printf("%04X:%04X\t\t%s", LC, atoi(Symbol[k].data), buf);
			fprintf(ObjSave, "%04X:%04X\t\t%s", LC, atoi(Symbol[k].data), buf);
		}

		if (*Symbol[k].word_type == 'w') LC += 2; //w면 주소값 2 증가, b면 주고값 1증가

		else if (*Symbol[k].word_type == 'b') LC += 1;
	}
	InstrP++;
	fclose(ObjSave);
}

//기호표 출력
void Symbol_Print()
{
	int i = 0;
	SymbolSave = fopen("symbol.txt", "w+");
	printf("\n *Symbol Table * \n");
	printf("SYMBOL \tDATA(ADDRESS)\tRELOCATION\n");
	for (i = 0; i < MaxS; i++)
	{
		if (!strcmp(Symbol[i].word_type, "w"))
		{
			printf("%s\t%X\t\t%d\n", Symbol[i].symbol, Symbol[i].lc, (Symbol[i].lc != atoi(Symbol[i].data) ? 1 : 0));
			fprintf(SymbolSave, "%s\t%X\t\t%d\n", Symbol[i].symbol, Symbol[i].lc, (Symbol[i].lc != atoi(Symbol[i].data) ? 1 : 0));
		}
		if (!strcmp(Symbol[i].word_type, "b"))
		{
			printf("%s\t%X\t\t%d\n", Symbol[i].symbol, Symbol[i].lc, (Symbol[i].lc != atoi(Symbol[i].data) ? 1 : 0));
			fprintf(SymbolSave, "%s\t%X\t\t%d\n", Symbol[i].symbol, Symbol[i].lc, (Symbol[i].lc != atoi(Symbol[i].data) ? 1 : 0));
		}
	}
	fclose(SymbolSave);
}

//메인 함수
void main(void)
{
	char buf[50];
	FILE *in;

	in = fopen("test1.asm", "r"); //어셈블러 소스코드
	Initialize(); //레지스터 표, 명령어 표 읽음

	printf("\nPass1:\n");

	while (1) //pass 1
	{
		fgets(buf, 30, in);
		if (feof(in)) break;
		pass1(buf);
	}

	Symbol_Print(); //기호표 출력

	rewind(in); //포인터 초기화

	LC = 0;
	ObjSave = fopen("objcode.txt", "w+");

	printf("\nPass2:\n");

	while (1) //pass 2
	{
		fgets(buf, 30, in);
		if (feof(in)) break;
		pass2(buf);
	}

	fclose(in);
}
